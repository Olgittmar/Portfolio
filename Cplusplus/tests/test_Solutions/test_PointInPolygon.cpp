// Std
#include <random>
#include <algorithm>
#include <ranges>
#include <sstream>
// Own
#include <test_PointInPolygon.h>

// ----------------------------------------------------------------------------
// TEST INTERNALS
// ----------------------------------------------------------------------------
// Builds a QPolygon from utils::Points, for verifying autogenerated tests.
// QPolygon uses a OddEvenFill algorithm to determine if a given point is inside
// it, which is basically the same algorithm that we use.
QPolygon
TestPointInPolygon::pointsToQPolygon( const std::vector<utils::Point>& v ) const
{
    QPolygon ret;
    for( const auto& p : v ){
        ret << QPoint( p.x(), p.y() );
    }
    return ret;
}

// Format for PointInPolygon input data should be something like
// [numVertices] <--- polygon 1
// V1
// V2
// ...
// Vn
// [numTestPoints] <--- points to test against polygon 1
// TP1
// TP2
// ...
// TPn
// [numVertices] <---- polygon 2
// ...
//
// Note that PointInPolygon assumes delimiter = '\n' & subdelimiter = ' '
QString
TestPointInPolygon::generatePIPTestData( bool stressTest, int maxNumPolygons, int maxNumVertices, int maxNumTestPoints)
{
    auto randPoint = []()
    {
        return utils::Point( utils::randInt(), utils::randInt() );
    };
    
    // Generates and writes a Polygon as well as testPoints to textStream with correct format.
    auto makeTestData = [maxNumVertices, maxNumTestPoints, stressTest, randPoint]( QTextStream& ts ) mutable
    {
        std::vector<utils::Point> pv( utils::randInt(3, maxNumVertices ) );

        std::generate( pv.begin(), pv.end(), randPoint );
        ts << QString::number( pv.size() ) << delim;
        for ( auto v : pv ) {
            ts << v.to_string().c_str() << delim;
        }

        pv.resize( utils::randInt(3, maxNumTestPoints ) );

        std::generate( pv.begin(), pv.end(), randPoint );
        ts << QString::number( pv.size() ) << delim;
        for ( auto v : pv ) {
            ts << v.to_string().c_str() << delim;
        }
    };

    QString ret;
    QTextStream out( &ret );
    const int numPolygons = utils::randInt( 1, maxNumPolygons );
    for( int i = 0; i <= numPolygons; ++i ){
        // Generate Polygon
        makeTestData( out );
    }
    out << '0';

    return ret;
}

QString
TestPointInPolygon::generatePIPAnswers( const QString& testData ) const
{
    QString answers;
    QPolygon poly;
    QPoint testPoint;
    QStringList lines = testData.split(delim);

    auto getPoint = [lines]( QStringList::const_iterator lineIt ) -> QPoint {
        QStringList coordstr = lineIt->split(subdelim);
        QPoint ret;
        bool ok;
        if( coordstr.size() != 2 ){
            qDebug() << "Unexpected number of arguments: " << (int)(lineIt - lines.cbegin());
        }
        ret.setX( coordstr.at(0).toInt(&ok) );
        if(!ok){
            qDebug() << "Failed to convert first argument to int: " << (int)(lineIt - lines.cbegin());
        }
        ret.setY( coordstr.at(1).toInt(&ok) );
        if(!ok){
            qDebug() << "Failed to convert second argument to int: " << (int)(lineIt - lines.cbegin());
        }
        return ret;
    };

    for( auto lineIt = lines.cbegin(); lineIt != lines.cend(); ) {
        bool ok;
        // Read numVertices
        int numVertices = lineIt->toInt(&ok);
        if(!ok){
            qDebug() << "Failed to read numVertices: " << (int)(lineIt - lines.cbegin());
            break;
        } else if( numVertices == 0 ) {
            break;
        } else {
            answers += '\n';
        }

        // Build polygon
        poly.clear();
        poly.resize(numVertices);
        for(int i = 0; i < numVertices; ++i ){
            poly.setPoint(i, getPoint( ++lineIt ));
        }

        // Read numTestPoints
        int numTestPoints = (++lineIt)->toInt(&ok);
        if(!ok){
            qDebug() << "Failed to read numTestPoints: " << (int)(lineIt - lines.cbegin());
        }

        // Test points
        for( int i = 0; i < numTestPoints; ++i ) {
            if( i > 0 ){
                answers += '\n';
            }
            testPoint = getPoint( ++lineIt );
            if( !poly.boundingRect().contains( testPoint ) ){
                answers += "out";
            } else if( poly.contains( testPoint ) ){
                //! Gotta check if contains(point) returns true if the point is on the QPolygon.
                answers += "in";
            } else if( poly.intersects( QPolygon( {testPoint} ) ) ){
                answers += "on";
            } else {
                answers += "out";
            }
        }
        ++lineIt;
    }
    return answers;
}

// ----------------------------------------------------------------------------
// TEST MANAGEMENT
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// TEST DATA
// ----------------------------------------------------------------------------
void
TestPointInPolygon::initTestCase_data()
{


    QTest::addColumn<MYTESTS>("index");
    QTest::addColumn<QString>("testdata");
    QTest::addColumn<QString>("expected");
    QString testData, expected;
    auto me = QMetaEnum::fromType<MYTESTS>();

    QTest::newRow(me.valueToKey( Empty ))
        << Empty
        << ""
        << "";
    QTest::newRow(me.valueToKey( InvalidFormat ))
        << InvalidFormat
        << "\t this*/shouldn't\\work \n0"
        << "";
    QTest::newRow(me.valueToKey( ExtraWhitespace ))
        << ExtraWhitespace
        << "  \t \t3\n  0\t 0\n10  0\n\t0 10\n1\n 5   5\n 0\n\t"
        << "in";
    QTest::newRow(me.valueToKey( Generic ))
        << Generic
        << "3\n0 0\n10 0\n0 10\n"
           "3\n4 5\n5 5\n6 5\n"
           "5\n41 -6\n-24 -74\n-51 -6\n73 17\n-30 -34\n"
           "2\n-12 -26\n39 -8\n0"
           << "in\non\nout\nout\nin";

    testData = generatePIPTestData();
    expected = generatePIPAnswers( testData );
    QTest::newRow(me.valueToKey( RandGen ))
        << RandGen
        << testData
        << expected;
    testData = generatePIPTestData( true );
    expected = generatePIPAnswers( testData );
    QTest::newRow(me.valueToKey( RandGenST ))
        << RandGenST
        << testData
        << expected;
    QTest::newRow(me.valueToKey( RandGenBM ))
        << RandGenBM
        << generatePIPTestData(true, 10, 1000, 100)
        << "";
}

// ----------------------------------------------------------------------------
// TESTS
// ----------------------------------------------------------------------------
void
TestPointInPolygon::PointInPolygon()
{
    QFETCH_GLOBAL(MYTESTS, index);
    QFETCH_GLOBAL(QString, testdata);
    QFETCH_GLOBAL(QString, expected);

    try {
        std::string res;
        std::ostringstream out;
        std::istringstream in( testdata.toStdString() );
    
        if( index == RandGenBM ){
            QBENCHMARK( Solutions::PointInPolygon( in, out ) );
        } else if( utils::isAnyOf( index, InvalidFormat, ExtraWhitespace ) ){
            QVERIFY_EXCEPTION_THROWN( Solutions::PointInPolygon( in, out ), std::invalid_argument );
        } else if( utils::isAnyOf( index, RandGen, RandGenST ) ) {
            res = Solutions::PointInPolygon( in, out );
            QVERIFY( res == expected.toStdString() );
            QVERIFY( out.str() == expected.toStdString() );
        } else {
            res = Solutions::PointInPolygon( in, out );
            QCOMPARE( res.c_str(), expected.toStdString().c_str() );
            QCOMPARE( out.str().c_str(), expected.toStdString().c_str() );
        }
    } catch( const std::exception& e ){
        QFAIL(e.what());
    }
}

// ----------------------------------------------------------------------------
QTEST_GUILESS_MAIN(TestPointInPolygon)
// ----------------------------------------------------------------------------
