// Std
#include <random>
#include <algorithm>
#include <ranges>
#include <sstream>
// Own
#include <test_PointInPolygon.h>
// Qt
#include <QPainter>

// ----------------------------------------------------------------------------
// TEST INTERNALS
// ----------------------------------------------------------------------------
// Builds a QPolygon from utils::Points, for verifying autogenerated tests.
// QPolygon uses a OddEvenFill algorithm to determine if a given point is inside
// it, which is basically the same algorithm that we use.
QPolygon
TestPointInPolygon::pointsToQPolygon( const std::vector<utils::Point>& v ) const
{
    QPolygon ret;
    for( const auto& p : v ){
        ret << QPoint( p.x(), p.y() );
    }
    return ret;
}

std::string
TestPointInPolygon::strDiff( const std::string& str1, const std::string& str2 ) const
{
    auto strDiffPos = std::mismatch( str1.begin(), str1.end(), str2.begin() );
    auto rStrDiffPos = std::mismatch( str1.rbegin(), str1.rend(), str2.rbegin() );

    std::string resDiff = std::string( strDiffPos.first, rStrDiffPos.first.base() );
    std::string expectedDiff = std::string( strDiffPos.second, rStrDiffPos.second.base() );
    return (resDiff + "\n\t!=\n" + expectedDiff);
}

// Format for PointInPolygon input data should be something like
// [numVertices] <--- polygon 1
// V1
// V2
// ...
// Vn
// [numTestPoints] <--- points to test against polygon 1
// TP1
// TP2
// ...
// TPn
// [numVertices] <---- polygon 2
// ...
//
// Note that PointInPolygon assumes delimiter = '\n' & subdelimiter = ' '
QString
TestPointInPolygon::generatePIPTestData( bool stressTest, int maxNumPolygons, int maxNumVertices, int maxNumTestPoints)
{
    auto randPoint = []()
    {
        return utils::Point( utils::randInt(), utils::randInt() );
    };
    
    // Generates and writes a Polygon as well as testPoints to textStream with correct format.
    auto makeTestData = [maxNumVertices, maxNumTestPoints, stressTest, randPoint]( QTextStream& ts ) mutable
    {
        std::vector<utils::Point> pv( utils::randInt(3, maxNumVertices ) );

        std::generate( pv.begin(), pv.end(), randPoint );
        ts << QString::number( pv.size() ) << delim;
        for ( auto v : pv ) {
            ts << v.to_string().c_str() << delim;
        }

        pv.resize( utils::randInt(3, maxNumTestPoints ) );

        std::generate( pv.begin(), pv.end(), randPoint );
        ts << QString::number( pv.size() ) << delim;
        for ( auto v : pv ) {
            ts << v.to_string().c_str() << delim;
        }
    };

    QString ret;
    QTextStream out( &ret );
    const int numPolygons = utils::randInt( 1, maxNumPolygons );
    for( int i = 0; i <= numPolygons; ++i ){
        // Generate Polygon
        makeTestData( out );
    }
    out << '0';

    return ret;
}

// TODO: we could probably draw on a pretend bitMap and check whether the testpoint has been drawn.
QString
TestPointInPolygon::generatePIPAnswers( const QString& testData ) const
{
    QString answers = "";
    QPoint testPoint;
    QStringList lines = testData.split(delim);

    // Lambdas used specifically for this function
    auto getPoint = [lines]( QStringList::const_iterator lineIt ) -> QPoint {
        QStringList coordstr = lineIt->split(subdelim);
        QPoint ret;
        bool ok;
        if( coordstr.size() != 2 ){
            qDebug() << "Unexpected number of arguments: " << (int)(lineIt - lines.cbegin());
        }
        ret.setX( coordstr.at(0).toInt(&ok) );
        if(!ok){
            qDebug() << "Failed to convert first argument to int: " << (int)(lineIt - lines.cbegin());
        }
        ret.setY( coordstr.at(1).toInt(&ok) );
        if(!ok){
            qDebug() << "Failed to convert second argument to int: " << (int)(lineIt - lines.cbegin());
        }
        return ret;
    };

    auto getYAt = []( const QLine& line, int x, int* out ) -> bool {
        if( line.dx() == 0 ) {
            return false;
        }
        double slope = (double)line.dy()/(double)line.dx();
        *out = line.p1().y() + qRound(slope * (x - line.p1().x()));
        return true;
    };
    auto getXAt = []( const QLine& line, int y, int* out ) -> bool {
        if( line.dy() == 0 ) {
            return false;
        }
        double invSlope = (double)line.dx()/(double)line.dy();
        *out = line.p1().x() + qRound(invSlope * (y - line.p1().y()));
        return true;
    };
    // end lambdas


    for( auto lineIt = lines.cbegin(); lineIt != lines.cend(); ) {
        bool ok;
        // Read numVertices
        int numVertices = lineIt->toInt(&ok);
        if(!ok){
            qDebug() << "Failed to read numVertices: " << (int)(lineIt - lines.cbegin());
            break;
        } else if( numVertices == 0 ) {
            break;
        } else if( lineIt != lines.cbegin() ) {
            answers += '\n';
        }

        // Build polygon
        QPolygon poly;
        poly.resize(numVertices);
        for(int i = 0; i < numVertices; ++i ){
            poly.setPoint(i, getPoint( ++lineIt ));
        }

        // Read numTestPoints
        int numTestPoints = (++lineIt)->toInt(&ok);
        if(!ok){
            qDebug() << "Failed to read numTestPoints: " << (int)(lineIt - lines.cbegin());
            break;
        }

        // Test points
        for( int i = 0; i < numTestPoints; ++i ) {
            if( i > 0 ){
                answers += '\n';
            }
            testPoint = getPoint( ++lineIt );
            
            if( !poly.boundingRect().contains( testPoint ) ) {
                answers += "out";
            } else if( poly.containsPoint( testPoint, Qt::OddEvenFill ) ) {
                answers += "in";
            } else if( poly.contains( testPoint )) {
                answers += "on";
            } else {
                // testPoint is not inside the polygon, neither is it one of the vertices, but it might be on the perimiter.
                QLine currLine;
                int x, y;
                auto pIt = poly.constBegin();
                while( pIt != poly.constEnd() ) {
                    currLine.setP1(*pIt);
                    currLine.setP2(( ++pIt != poly.constEnd() ? *pIt : poly.first() ));
                    // If testPoint isn't close to this line we can just move on.
                    if( !QRect::span( currLine.p1(), currLine.p2() ).contains( testPoint ) ){
                        continue;
                    }
                    // If the lines y/x-coordinate at testPoint.x/y is equal to testPoint.y/x, then the point is along the line,
                    // and since we already checked that it is within the span of the line, the point must be on the line.
                    if( ( getYAt( currLine, testPoint.x(), &y ) && testPoint.y() == y )
                     || ( getXAt( currLine, testPoint.y(), &x ) && testPoint.x() == x ) ) {
                        answers += "on";
                        break;
                    }
                }
                if( pIt == poly.constEnd() ){
                    // If we checked every line of the polygon, and the point isn't on any of them,
                    // since we already checked inside, the point must be outside the polygon.
                    answers += "out";
                }
            }
        }
        ++lineIt;
    }
    return answers;
}

// ----------------------------------------------------------------------------
// TEST MANAGEMENT
// ----------------------------------------------------------------------------


// ----------------------------------------------------------------------------
// TEST DATA
// ----------------------------------------------------------------------------
void
TestPointInPolygon::initTestCase_data()
{
    QTest::addColumn<MYTESTS>("index");
    QTest::addColumn<QString>("testdata");
    QTest::addColumn<QString>("expected");
    QString testData, expected;
    auto me = QMetaEnum::fromType<MYTESTS>();

    QTest::newRow(me.valueToKey( Empty ))
        << Empty
        << ""
        << "";
    
    QTest::newRow(me.valueToKey( InvalidFormat ))
        << InvalidFormat
        << "\t this*/shouldn't\\work \n0"
        << "";
    
    QTest::newRow(me.valueToKey( ExtraWhitespace ))
        << ExtraWhitespace
        << "  \t \t3\n  0\t 0\n10  0\n\t0 10\n1\n 5   5\n 0\n\t"
        << "in";
    
    testData = "3\n0 0\n10 0\n0 10\n"
               "3\n4 5\n5 5\n6 5\n"
               "5\n41 -6\n-24 -74\n-51 -6\n73 17\n-30 -34\n"
               "2\n-12 -26\n39 -8\n0";
    expected = "in\non\nout\nout\nin";
    QTest::newRow(me.valueToKey( Generic ))
        << Generic
        << testData
        << expected;

    expected = generatePIPAnswers( testData );
    QTest::newRow(me.valueToKey( GenericAutogenAnswers ))
        << Generic
        << testData
        << expected;
    
    testData = generatePIPTestData();
    expected = generatePIPAnswers( testData );
    QTest::newRow(me.valueToKey( RandGen ))
        << RandGen
        << testData
        << expected;
    
    testData = generatePIPTestData( true );
    expected = generatePIPAnswers( testData );
    QTest::newRow(me.valueToKey( RandGenST ))
        << RandGenST
        << testData
        << expected;
    
    QTest::newRow(me.valueToKey( RandGenBM ))
        << RandGenBM
        << generatePIPTestData(true, 10, 1000, 100)
        << "";
}

// ----------------------------------------------------------------------------
// TESTS
// ----------------------------------------------------------------------------
void
TestPointInPolygon::PointInPolygon()
{
    QFETCH_GLOBAL(MYTESTS, index);
    QFETCH_GLOBAL(QString, testdata);
    QFETCH_GLOBAL(QString, expected);

    try {
        std::string res;
        std::ostringstream out;
        std::istringstream in( testdata.toStdString() );
    
        if( index == RandGenBM ){
            QBENCHMARK( Solutions::PointInPolygon( in, out ) );
        } else if( utils::isAnyOf( index, InvalidFormat, ExtraWhitespace ) ){
            QVERIFY_EXCEPTION_THROWN( Solutions::PointInPolygon( in, out ), std::invalid_argument );
        } else if( utils::isAnyOf( index, RandGen, RandGenST ) ) {
            res = Solutions::PointInPolygon( in, out );
            QCOMPARE( res.size(), expected.size() );
            QCOMPARE( out.str().size(), expected.size() );
            QVERIFY2( res == expected.toStdString(), strDiff( res, expected.toStdString() ).c_str() );
            QVERIFY2( out.str() == expected.toStdString(), strDiff( res, expected.toStdString() ).c_str() );
        } else {
            res = Solutions::PointInPolygon( in, out );
            QCOMPARE( out.str().c_str(), expected.toStdString().c_str() );
            QCOMPARE( res.c_str(), expected.toStdString().c_str() );
        }
    } catch( const std::exception& e ){
        QFAIL(e.what());
    }
}

// ----------------------------------------------------------------------------
QTEST_GUILESS_MAIN(TestPointInPolygon)
// ----------------------------------------------------------------------------