// Std
#include <random>
#include <algorithm>
#include <ranges>
#include <sstream>
// Own
#include <test_PointInPolygon.h>

// ----------------------------------------------------------------------------
// TEST INTERNALS
// ----------------------------------------------------------------------------
// Builds a QPolygon from utils::Points, for verifying autogenerated tests.
// QPolygon uses a OddEvenFill algorithm to determine if a given point is inside
// it, which is basically the same algorithm that we use.
QPolygon
TestPointInPolygon::pointsToQPolygon( const std::vector<utils::Point>& v ) const
{
    QPolygon ret;
    for( const auto& p : v ){
        ret << QPoint( p.x(), p.y() );
    }
    return ret;
}
// ----------------------------------------------------------------------------
// TEST MANAGEMENT
// ----------------------------------------------------------------------------
// Format for PointInPolygon input data should be something like
// [numVertices] <--- polygon 1
// V1
// V2
// ...
// Vn
// [numTestPoints] <--- points to test against polygon 1
// TP1
// TP2
// ...
// TPn
// [numVertices] <---- polygon 2
// ...
//
// Note that PointInPolygon assumes delimiter = '\n' & subdelimiter = ' '

// TODO: Qt Resource instead of file?
void
TestPointInPolygon::initTestCase()
{
    QFETCH_GLOBAL(MYTESTS, index);
    if( !utils::isAnyOf(index, Generic, RandGen, RandGenST, RandGenBM) ){
        // Nothing to do here.
        return;
    }

    QFETCH_GLOBAL(QString, testfile);
    QFile tf( testfile + QString(".in"), this );
    if ( !tf.open( QIODevice::WriteOnly | QIODevice::Text ) ) {
	    qDebug() << "Failed to open test inputfile: " << testfile << ".in";
        return; // Throw exception?
    }

    {
        std::vector<utils::Point> vertices, testPoints;
        if ( index == RandGen ) {
	        // Flaky setup for generic test,
            // contents should preferably be completely unknown at time of test.
            QTextStream out( &tf );

            for( int i = 0; i <= utils::randInt(1, maxNumPolygons); ++i ){
	            // Generate large complex polygon
	            vertices.resize( utils::randInt( 1, reasonableNumPoints ) );
	            std::generate( vertices.begin(), vertices.end(), randPoint );
                // Write polygon
                out << vertices.size() << delim;
                for ( auto v : vertices ) {
	                out << v.to_string().c_str() << delim;
                }
	            // Generate testpoints
	            testPoints.resize( utils::randInt( 1, maxNumTestPoints ) );
	            std::generate( testPoints.begin(), testPoints.end(), randPoint );
                // Write testPoints
                out << testPoints.size();
                for ( auto p : testPoints ) {
	                out << p.to_string().c_str() << delim;
                }
            }
        } else if ( utils::isAnyOf( index, RandGenST, RandGenBM ) ) {
            QTextStream out( &tf );

            for( int i = 0; i <= maxNumPolygons; ++i ){
	            // Generate large complex polygon
	            vertices.resize( maxNumVertices );
	            std::generate( vertices.begin(), vertices.end(), randPoint );
                // Write polygon
                out << vertices.size() << delim;
                for ( auto v : vertices ) {
	                out << v.to_string().c_str() << delim;
                }
	            // Generate testpoints
	            testPoints.resize( maxNumTestPoints );
	            std::generate( testPoints.begin(), testPoints.end(), randPoint );
                // Write testPoints
                out << testPoints.size();
                for ( auto p : testPoints ) {
	                out << p.to_string().c_str() << delim;
                }
            }
            if( out.status() != QTextStream::Ok ){
                qDebug() << "Failed to write to device.";
            }
        }
        tf.close();
    }

    if( index != RandGenBM ){
        // Generate expected answers from contents of testfile using QPolygon
        if ( !tf.open( QIODevice::ReadOnly | QIODevice::Text ) ) {
	        qDebug() << "Failed to open test inputfile: " << testfile << ".in";
            return;
        }

        QFile ansf( testfile + QString(".ans"), this );
        if ( !ansf.open( QIODevice::WriteOnly | QIODevice::Text ) ) {
	        qDebug() << "Failed to open test outputfile: " << testfile << ".ans";
            return;
        }

        QTextStream in( &tf );
        QTextStream out( &ansf );
        int lineNum = 0;
        int x, y, numVertices, numTestPoints;
        bool ok;
        QString line;
        QStringList coordstr;
        QPolygon poly;
        QPoint testPoint;

        while( !in.atEnd() ) {
            in.readLineInto(&line);
            // Read numVertices
            numVertices = line.toInt(&ok);
            if(!ok){
                qDebug() << "Failed to read numVertices: " << lineNum;
            }
            ++lineNum;
            // Construct polygon
            poly.clear();
            poly.resize(numVertices);
            for(int i = 0; i < numVertices; ++i ){
                in.readLineInto(&line);
                coordstr = line.split(subdelim);
                if( coordstr.size() != 2 ){
                    qDebug() << "Unexpected number of arguments: " << lineNum;
                }
                x = coordstr.at(0).toInt(&ok);
                if(!ok){
                    qDebug() << "Failed to convert first argument to int: " << lineNum;
                }
                y = coordstr.at(1).toInt(&ok);
                if(!ok){
                    qDebug() << "Failed to convert second argument to int: " << lineNum;
                }
                poly.setPoint(i, x, y);
                ++lineNum;
            }
            in.readLineInto(&line);
            numTestPoints = line.toInt(&ok);
            if(!ok){
                qDebug() << "Failed to read numTestPoints: " << lineNum;
            }
            ++lineNum;
            for( int i = 0; i < numTestPoints; ++i ){
                in.readLineInto(&line);
                coordstr = line.split(subdelim);
                if( coordstr.size() != 2 ){
                    qDebug() << "Unexpected number of arguments: " << lineNum;
                }
                x = coordstr.at(0).toInt(&ok);
                if(!ok){
                    qDebug() << "Failed to convert first argument to int: " << lineNum;
                }
                y = coordstr.at(1).toInt(&ok);
                if(!ok){
                    qDebug() << "Failed to convert second argument to int: " << lineNum;
                }
                testPoint = QPoint(x, y);
                ++lineNum;

                if( !poly.boundingRect().contains( testPoint ) ){
                    out << "out" << delim;
                } else if( poly.contains( testPoint ) ){
                    //! Gotta check if contains(point) returns true if the point is on the polygon.
                    out << "in" << delim;
                } else if( poly.intersects( QPolygon( testPoint ) ) ){
                    out << "on" << delim;
                }
            }
        }
        tf.close();
        ansf.close();
    }
}
// ----------------------------------------------------------------------------
// TEST DATA
// ----------------------------------------------------------------------------
void
TestPointInPolygon::initTestCase_data()
{
    QTest::addColumn<MYTESTS>("index");
    QTest::addColumn<QString>("testfile");
    
    QTest::newRow(qt_getEnumName( Empty ))
        << Empty
        << testdir + "/empty";
    QTest::newRow(qt_getEnumName( InvalidFormat ))
        << InvalidFormat
        << testdir + "/inv";
    QTest::newRow(qt_getEnumName( ExtraWhitespace ))
        << ExtraWhitespace
        << testdir + "/ews";
    QTest::newRow(qt_getEnumName( Generic ))
        << Generic
        << testdir + "/gen0";
    QTest::newRow(qt_getEnumName( RandGen ))
        << RandGen
        << testdir + "/gen1";
    QTest::newRow(qt_getEnumName( RandGenST ))
        << RandGenST
        << testdir + "/gen2";
    QTest::newRow(qt_getEnumName( RandGenBM ))
        << RandGenBM
        << testdir + "/gen3";
}

// ----------------------------------------------------------------------------
// TESTS
// ----------------------------------------------------------------------------
void
TestPointInPolygon::PointInPolygon()
{
    QFETCH_GLOBAL(MYTESTS, index);
    QFETCH_GLOBAL(QString, testfile);

    try {
        std::ifstream ifstrm( testfile.toStdString() + ".in" );
        std::ifstream ansfstrm( testfile.toStdString() + ".ans" );
        std::string res, expected;
        std::ostringstream out(res);
    
        if( !ifstrm.good() ){
            QFAIL("Failed to read from testfile.");
        }
        Solutions::PointInPolygon( ifstrm, out );
        if( ifstrm.is_open() ){
            ifstrm.close();
        }

        if( !ansfstrm.good() ){
            QFAIL("Failed to read from answerfile.");
        }
        ansfstrm >> expected;
        if( ansfstrm.is_open() ){
            ansfstrm.close();
        }

        QCOMPARE(res, expected);
        if( index == RandGenBM ){
            QBENCHMARK( Solutions::PointInPolygon( ifstrm, out ) );
        }
    } catch( const std::exception& e ){
        QFAIL(e.what());
    }
}

// ----------------------------------------------------------------------------
QTEST_MAIN(TestPointInPolygon)
// ----------------------------------------------------------------------------
